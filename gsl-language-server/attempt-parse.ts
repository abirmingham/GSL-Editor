import { readFile } from 'fs';
import { basename } from 'path';
import {
    BaseErrorListener,
    CharStreams,
    CommonTokenStream,
    ParseTree,
    TerminalNode,
} from 'antlr4ng';
import { GslLexer } from './antlr/autogenerated/GslLexer';
import { GslParser } from './antlr/autogenerated/GslParser';

// These appear to be legitimately uncompilable,
// or are just really objectionable,
// or contain commands no longer used in any game (e.g. bmgr)
const SKIP = new Set([
    'S00001.gsl',
    'S00077.gsl',
    'S21312.gsl',
    's20303.gsl',
    'S10393.gsl',
    'S10419.gsl',
    'S02453.gsl',
    'S07487.gsl',
    'S09805.gsl',
    'S13707.gsl',
    'S00126.gsl',
    'S08717.gsl',
    'S19490.gsl',
    'S11231.gsl',
    'S12158.gsl',
    'S12398.gsl',
    'S11201.gsl',
    'S12891.gsl',
    'S12892.gsl',
    'S14138.gsl',
    'S14922.gsl',
    'S00606.gsl',
]);
const MIN_LENGTH = 30; // a lot of these tiny scripts seem to be invalid

const noOpErrorListener = new BaseErrorListener();
const reportAmbiguity =
    noOpErrorListener.reportAmbiguity.bind(noOpErrorListener);
const reportAttemptingFullContext =
    noOpErrorListener.reportAttemptingFullContext.bind(noOpErrorListener);
const reportContextSensitivity =
    noOpErrorListener.reportContextSensitivity.bind(noOpErrorListener);

const countTerminalTokens = (rule: ParseTree): number => {
    let count = rule instanceof TerminalNode ? 1 : 0;
    const childCount = rule.getChildCount();
    for (let i = 0; i < childCount; i++) {
        const child = rule.getChild(i);
        if (!child) throw new Error('Failed to find child');
        count += countTerminalTokens(child);
    }
    return count;
};

// Define the attemptParse function
function attemptParse(content: string, fileName: string): void {
    fileName = basename(fileName);
    if (content.length < MIN_LENGTH || SKIP.has(fileName)) {
        // There's some weird short scripts like S20096
        console.log(`${fileName}; SKIP`);
        return;
    }
    const inputStream = CharStreams.fromString(content);
    const lexer = new GslLexer(inputStream);
    lexer.removeErrorListeners();
    lexer.addErrorListener({
        syntaxError: (
            recognizer,
            offendingSymbol,
            line,
            charPositionInLine,
            msg,
            e
        ) => {
            const lines = content.split('\n');
            console.log(
                `${fileName}; LEXER_ERROR line=${line} msg=${msg} content=${
                    lines[line - 1]
                }`
            );
        },
        reportAmbiguity,
        reportAttemptingFullContext,
        reportContextSensitivity,
    });
    const tokenStream = new CommonTokenStream(lexer, 0);
    const parser = new GslParser(tokenStream);
    parser.removeErrorListeners();
    parser.addErrorListener({
        syntaxError: (
            recognizer,
            offendingSymbol,
            line,
            charPositionInLine,
            msg,
            e
        ) => {
            const lines = content.split('\n');
            console.log(
                `${fileName}; PARSER_ERROR line=${line} msg=${msg} content=${
                    lines[line - 1]
                }`
            );
        },
        reportAmbiguity,
        reportAttemptingFullContext,
        reportContextSensitivity,
    });

    const scriptContext = parser.script();

    const terminalTokenCount = countTerminalTokens(scriptContext);

    // Implement parsing logic here, now aware of the file's name
    console.log(
        `${fileName}; DONE length=${scriptContext.getText().length}/${
            content.length
        }; terminalTokens=${terminalTokenCount}`
    );
}

// Check if at least one file path is provided as a command-line argument
if (process.argv.length < 3) {
    console.log(
        'Usage: ts-node attempt-parse.ts <file_path1> <file_path2> ...'
    );
    process.exit(1);
}

// Iterate over all provided file paths
process.argv.slice(2).forEach((filePath) => {
    // Read the entire contents of each file
    readFile(filePath, 'utf8', (err, data) => {
        if (err) {
            console.error(`Error reading the file ${filePath}:`, err.message);
            return;
        }

        // Pass the contents to attemptParse function along with the file name
        attemptParse(data, filePath);
    });
});
