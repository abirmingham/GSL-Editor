import {
    BaseErrorListener,
    CharStreams,
    CommonTokenStream,
    ParserRuleContext,
} from 'antlr4ng';
import { GslParser } from './antlr/autogenerated/GslParser';
import { GslLexer } from './antlr/autogenerated/GslLexer';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { Diagnostic, DiagnosticSeverity } from 'vscode-languageserver/node';

const MAX_DIAGNOSTICS = 100;
const CHARACTER_LIMIT = 120;
const DIAGNOSTIC_SOURCE = 'GSL Language Server';

export interface ParseResult {
    exists: true;
    lexer: GslLexer;
    tokenStream: CommonTokenStream;
    parser: GslParser;
    syntaxTree: ParserRuleContext;
    diagnostics: Diagnostic[];
}

export type NoParseResult = { exists: false };

const documentStateMap = new Map<string, ParseResult>();

export const parseDocument = (document: TextDocument): ParseResult => {
    // Lex/parse the document
    const text = document.getText();
    const lexer = new GslLexer(CharStreams.fromString(text.trim() + '\r\n'));
    const tokenStream = new CommonTokenStream(lexer, 0);
    const parser = new GslParser(tokenStream);

    const diagnostics: Diagnostic[] = getTextScanDiagnostics(text);

    addDiagnosticsListener(parser, (diagnostic) => {
        const exceedsMax = diagnostics.length >= MAX_DIAGNOSTICS;
        if (!exceedsMax) diagnostics.push(diagnostic);
        return exceedsMax; // Tell listener we don't want anymore diagnostics (for efficiency)
    });
    const syntaxTree = parser.script();

    const result = {
        exists: true,
        lexer,
        tokenStream,
        parser,
        syntaxTree,
        diagnostics,
    } as const;
    documentStateMap.set(document.uri, result);
    return result;
};

const getTextScanDiagnostics = (text: string): Diagnostic[] => {
    const diagnostics = new Array<Diagnostic>();
    let line = 0;
    let column = 0;
    for (let i = 0; i < text.length; i++) {
        if (text[i] === '\n') {
            line += 1;
            column = 1;
            continue;
        }
        column += 1;
        if (column > CHARACTER_LIMIT) {
            diagnostics.push({
                severity: DiagnosticSeverity.Error,
                range: {
                    start: {
                        line: line - 1,
                        character: 1,
                    },
                    end: {
                        line: line,
                        character: column,
                    },
                },
                message: `Line exceeds ${CHARACTER_LIMIT} characters`,
                source: DIAGNOSTIC_SOURCE,
            });
        }
    }
    return diagnostics;
};

export const getLastParseResult = (
    documentUri: string
): ParseResult | undefined => {
    return documentStateMap.get(documentUri);
};

export const forgetDocument = (documentUri: string): void => {
    documentStateMap.delete(documentUri);
};

const addDiagnosticsListener = (
    parser: GslParser,
    callback: (diagnostic: Diagnostic) => boolean
) => {
    const noOpErrorListener = new BaseErrorListener();
    const reportAmbiguity =
        noOpErrorListener.reportAmbiguity.bind(noOpErrorListener);
    const reportAttemptingFullContext =
        noOpErrorListener.reportAttemptingFullContext.bind(noOpErrorListener);
    const reportContextSensitivity =
        noOpErrorListener.reportContextSensitivity.bind(noOpErrorListener);

    let halt = false;
    parser.addErrorListener({
        syntaxError: (
            _recognizer,
            offendingSymbol,
            line,
            charPositionInLine,
            msg,
            _e
        ) => {
            if (halt) return;
            halt = callback({
                severity: DiagnosticSeverity.Error,
                range: {
                    start: {
                        line: line - 1,
                        character: charPositionInLine,
                    },
                    end: {
                        line: line - 1,
                        character:
                            charPositionInLine +
                            (offendingSymbol?.text?.length || 0),
                    },
                },
                message: msg,
                source: DIAGNOSTIC_SOURCE,
            });
        },
        reportAmbiguity,
        reportAttemptingFullContext,
        reportContextSensitivity,
    });
};
