import { DocumentHighlight } from 'vscode-languageclient';
import { TerminalNode, Token } from 'antlr4ng';
import * as LexerUtil from '../util/LexerUtil';
import { ParseResult } from '../ParsingManager';
import { createHighlightRange, getTokenHighlight } from './HighlightUtil';
import { GslLexer } from '../antlr/autogenerated/GslLexer';
import {
    ElseContext,
    ElseIfContext,
    IfContext,
    MatchMarkerContext,
} from '../antlr/autogenerated/GslParser';
import { isDefined } from '../util/TypeUtil';
import {
    getSiblings,
    getToken,
    findAncestor,
    findChildren,
    getTokenType,
    findNodeForToken,
} from '../util/ParserUtil';

export const handleBlockHighlight = (
    _tokens: Token[],
    { token }: LexerUtil.FindTokenResult,
    { syntaxTree }: ParseResult
): DocumentHighlight[] => {
    const node = findNodeForToken(syntaxTree, token);
    if (!node) {
        console.error('Failed to find node in parse tree');
        return [];
    }
    // Handle match marker block
    if (
        (token.type === GslLexer.COLON || token.type === GslLexer.DOT) &&
        node.parent instanceof MatchMarkerContext
    ) {
        return [
            ...handleMatchMarkerTitleLine(node.parent),
            ...handleMatchMarkerClosingDot(node.parent),
        ];
    }
    // Handle ifblock tokens
    if (isIfBlockToken(token, node)) {
        const context = findAncestor(node, (n) => n instanceof IfContext, true);
        if (!context) {
            console.error('Failed to find if context for token: ' + token.text);
            return [];
        }
        const blocks = [
            context,
            ...findChildren(
                context,
                (n) => n instanceof ElseIfContext || n instanceof ElseContext
            ),
        ];
        return [
            ...blocks.map((n) => getToken(n.getChild(0))!), // if/ifnot/else etc
            getToken(context.getChild(context.getChildCount() - 2)), // dot
        ]
            .filter(isDefined)
            .map((t) => getTokenHighlight(t));
    }
    // Handle all other blocks
    return [
        getTokenHighlight(token),
        ...getSiblings(node)
            .map(getToken)
            .filter(LexerUtil.isBlockSymbol)
            .map((t) => getTokenHighlight(t)),
    ];
};

const isIfBlockToken = (token: Token, node: TerminalNode): boolean => {
    if (LexerUtil.Symbols.IfBlockTokens.has(token.type)) return true
    return token.type === GslLexer.DOT && node.parent instanceof IfContext
}

const handleMatchMarkerTitleLine = (
    node: MatchMarkerContext
): DocumentHighlight[] => {
    const tokens = findChildren(node, (n) => {
        const tokenType = getTokenType(n);
        if (tokenType === GslLexer.COLON) return true;
        if (tokenType === GslLexer.STRING) {
            return { halt: true, include: true };
        }
    })
        .map(getToken)
        .filter(isDefined);
    if (tokens.length === 0) return [];
    return [createHighlightRange(tokens)];
};

const handleMatchMarkerClosingDot = (
    node: MatchMarkerContext
): DocumentHighlight[] => {
    return findChildren(
        node,
        (n) =>
            getTokenType(n) === GslLexer.DOT && {
                halt: true,
                include: true,
            },
        { reverse: true }
    )
        .map(getToken)
        .filter(isDefined)
        .map((t) => getTokenHighlight(t));
};
