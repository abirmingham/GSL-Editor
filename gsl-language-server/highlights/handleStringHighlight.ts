import {
    DocumentHighlight,
    DocumentHighlightParams,
} from 'vscode-languageclient';
import { Token } from 'antlr4ng';
import * as LexerUtil from '../util/LexerUtil';
import { highlightVariables } from './handleVariableHighlight';
import { ParseResult } from '../ParsingManager';
import { MatchMarkerContext } from '../antlr/autogenerated/GslParser';
import { handleBlockHighlight } from './handleBlockHighlight';
import { GslLexer } from '../antlr/autogenerated/GslLexer';
import { findNodeForToken } from '../util/ParserUtil';

// TODO fix node reference highlighting in strings
// The issue is that

export const handleStringHighlight = (
    tokens: Token[],
    { token, index }: LexerUtil.FindTokenResult,
    parseResult: ParseResult,
    { position }: DocumentHighlightParams
): DocumentHighlight[] => {
    const { text, column } = token;
    if (!text) return [];

    const node = findNodeForToken(parseResult.syntaxTree, token);
    if (!node) {
        console.error('Failed to find node in parse tree');
        return [];
    }
    // Handle block highlighting
    if (node.parent instanceof MatchMarkerContext) {
        const matchMarkerColon = LexerUtil.findPreviousToken(
            tokens,
            index - 1,
            (t) => t.type === GslLexer.COLON
        );
        if (!matchMarkerColon) {
            console.error('Expected matchmarker colon');
            return [];
        }
        return handleBlockHighlight(tokens, matchMarkerColon, parseResult);
    }

    // Handle variable highlighting
    let cursorPosition = position.character - column;
    if (text[cursorPosition] !== '$') {
        // Unless we're already at the start of a variable reference,
        // move one backwards, to account for the case of:
        // $V1<cursor><space>
        cursorPosition--;
    }
    for (let i = cursorPosition; i >= 0; i--) {
        // Scan backwards for dollar sign
        if (!text[i].match(/[\$a-zA-Z0-9_]/)) {
            // Encountered non-variable characters looking
            // for dollar sign
            return [];
        }
        if (text[i] === '$') {
            // Scan forwards for end of variable name
            let j = i + 1;
            while (j < text.length) {
                if (!text[j].match(/[a-zA-Z_]/)) {
                    break;
                }
                j++;
            }
            // See if it's a reference
            let txt = text.slice(i, j);
            if (txt.match(/^\$[CROPEVBAST]$/) && isNumber(text[j])) {
                // Add the number (TODO this is kind of hacky)
                txt += text[j];
            }
            const variable = LexerUtil.getVariableFromTextToken(txt);
            if (variable) {
                return highlightVariables(
                    token,
                    variable.type,
                    variable.name,
                    parseResult.syntaxTree
                );
            }
        }
    }
    return [];
};

const isNumber = (character: string | undefined): boolean => {
    if (!character) return false;
    return String(Number.parseInt(character)) === character;
};
