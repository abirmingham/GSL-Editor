import { format } from 'prettier';

import { GslLexer } from '../antlr/autogenerated/GslLexer';
import { CharStreams, CommonTokenStream } from 'antlr4ng';
import { GslParser } from '../antlr/autogenerated/GslParser';
import { GslAst, buildAst } from './AstBuilder';
import { printGslAsPrettierDoc } from './Printer';
import { preprocessGsl } from './Preprocessor';
import { postprocessGsl } from './Postprocessor';

const failOnSyntaxError = {
    syntaxError: () => {
        throw new Error('Syntax error');
    },
    reportAmbiguity: () => {},
    reportAttemptingFullContext: () => {},
    reportContextSensitivity: () => {},
};

const parsers = {
    'gsl-parser': {
        astFormat: 'gsl-ast',
        parse: (text: string, _options: unknown): GslAst => {
            // Lex/parse the document
            const lexer = new GslLexer(CharStreams.fromString(text));
            lexer.addErrorListener(failOnSyntaxError);

            const tokenStream = new CommonTokenStream(lexer, 0);

            const parser = new GslParser(tokenStream);
            parser.addErrorListener(failOnSyntaxError);

            const concreteSyntaxTree = parser.script();

            const ast = buildAst(concreteSyntaxTree);
            if (!ast) throw new Error('Failed to get AST');
            return ast;
        },
        /**
         * Get the starting character index of this node.
         * WARNING: It seems we aren't currently using any prettier
         * features that use this, so the locStarts are untested and
         * may be incorrect!
         */
        locStart: (node: GslAst): number => node.locStart,
        /**
         * Get the starting character index of this node.
         * WARNING: See `locStart` warning which applies here too.
         */
        locEnd: (node: GslAst): number => node.locEnd,
    },
} as const;

export const runPrettier = (
    text: string,
    eol: 'crlf' | 'lf'
): Promise<string> => {
    return format(preprocessGsl(text), {
        parser: 'gsl-parser',
        plugins: [
            {
                parsers,
                languages: [
                    {
                        name: 'GSL',
                        extensions: ['.gsl'],
                        parsers: ['gsl-parser'],
                    },
                ],
                printers: {
                    'gsl-ast': {
                        // TODO types are wrong for the print(selector)
                        print: printGslAsPrettierDoc as any,
                    },
                },
                options: {},
                defaultOptions: {
                    printWidth: 999999, // Never collapse lines
                    endOfLine: 'crlf',
                },
            },
        ],
    })
        .then(postprocessGsl)
        .then(replaceEol(eol));
};

const replaceEol = (eol: 'crlf' | 'lf') => (text: string) =>
    eol === 'crlf'
        ? text // text is already CRLF
        : text.replaceAll('\r\n', '\n');
