import {
    CommonTokenStream,
    Interval,
    ParseTree,
    ParserRuleContext,
    RuleContext,
    TerminalNode,
    Token,
} from 'antlr4ng';
import * as LexerUtil from './LexerUtil';
import { Position } from 'vscode-languageserver';
import { GslLexer } from '../antlr/autogenerated/GslLexer';
import {
    FastpushContext,
    MatchMarkerContext,
    PushContext,
    ScriptContext,
} from '../antlr/autogenerated/GslParser';

export const findNodeForToken = (
    node: ParseTree,
    token: Token
): TerminalNode | undefined => {
    if (node instanceof TerminalNode) {
        if (node.symbol !== token) return;
        return node;
    }

    // Binary search to correct child, then recurse
    let min = 0;
    let max = node.getChildCount() - 1;

    while (min <= max) {
        const mid = min + Math.floor((max - min) / 2);
        const child = node.getChild(mid);
        if (!child) throw new Error('Failed to find middle child');

        const { tokenIndex } = token;
        const childInterval = getTokenInterval(child);
        if (
            tokenIndex >= childInterval.start &&
            tokenIndex <= childInterval.stop
        ) {
            return findNodeForToken(child, token);
        }
        if (tokenIndex < childInterval.start) {
            max = mid - 1;
            continue;
        }
        if (tokenIndex > childInterval.stop) {
            min = mid + 1;
            continue;
        }
        throw new Error('Failed to locate token index in interval');
    }
};

const getTokenInterval = (node: ParseTree): Interval => {
    if (node instanceof TerminalNode) {
        return Interval.of(node.symbol.tokenIndex, node.symbol.tokenIndex);
    }
    if (!(node instanceof ParserRuleContext)) {
        throw new Error('Failed to identify node' + node.toString());
    }
    const start = node.start?.tokenIndex;
    const stop = node.stop?.tokenIndex;
    if (start === undefined || stop === undefined) {
        throw new Error('Failed to find start|stop');
    }
    return Interval.of(start, stop);
};

export const getFirstToken = (node: ParseTree): Token => {
    const token = getFirstTokenHelper(node);
    if (!token) throw new Error('Failed to find first token');
    return token;
};
const getFirstTokenHelper = (node: ParseTree): Token | undefined => {
    if (node instanceof TerminalNode) return node.symbol;
    for (let i = 0; i < node.getChildCount(); i++) {
        const token = getFirstTokenHelper(node.getChild(i)!);
        if (token) return token;
    }
};

export const getLastToken = (node: ParseTree): Token => {
    const token = getLastTokenHelper(node);
    if (!token) throw new Error('Failed to find first token');
    return token;
};
const getLastTokenHelper = (node: ParseTree): Token | undefined => {
    if (node instanceof TerminalNode) return node.symbol;
    for (let i = node.getChildCount() - 1; i >= 0; i--) {
        const token = getLastTokenHelper(node.getChild(i)!);
        if (token) return token;
    }
};

export const getSiblings = (node: ParseTree): ParseTree[] => {
    return node.parent ? findChildren(node.parent) : [];
};

export type FindChildrenPredicate = (
    child: ParseTree,
    index: number
) => { halt: boolean; include: boolean } | boolean | undefined;

/**
 * Find the children of `node` for which `predicate` returns true.
 * Results will be returned only if `predicate` returns `{ halt: true }`.
 */
export const findChildren = <T extends ParseTree>(
    node: ParseTree,
    predicate?: FindChildrenPredicate,
    options?: { reverse: boolean }
): ParseTree[] => {
    const results = [];
    const iter = options?.reverse
        ? getIterator(node.getChildCount() - 1, 0)
        : getIterator(0, node.getChildCount() - 1);
    while (iter.hasNext()) {
        const child = node.getChild(iter.next());
        if (child && child !== node) {
            const predResult = predicate
                ? predicate(child, iter.index() - 1)
                : true;
            if (
                predResult &&
                (typeof predResult === 'boolean' || predResult.include)
            ) {
                results.push(child);
            }
            if (typeof predResult === 'object' && predResult.halt) {
                break;
            }
        }
    }
    return results;
};

export const findAncestor = (
    node: ParseTree,
    predicate: (node: ParseTree) => boolean | null | undefined,
    includeSelf = false
): ParseTree | undefined => {
    let n: ParseTree | null = includeSelf ? node : node.parent;
    while (n) {
        if (predicate(n)) return n;
        n = n.parent;
    }
};

export type StackScope =
    | ScriptContext
    | MatchMarkerContext
    | PushContext
    | FastpushContext;

/**
 * @returns the enclosing mm/push/fastpush contexts that set/clear the stack
 * for this variable type.
 */
export const findStackScopes = (
    origin: TerminalNode,
    variableType: number
): StackScope[] => {
    const isPushed = LexerUtil.Symbols.VariablesPushed.has(variableType);
    const isFastpushed =
        LexerUtil.Symbols.VariablesFastpushed.has(variableType);

    const scopes = new Array<StackScope>();

    let node: ParseTree | undefined = origin;
    while (node) {
        node = findAncestor(
            node,
            (n) =>
                n instanceof ScriptContext ||
                n instanceof MatchMarkerContext ||
                (n instanceof PushContext && isPushed) ||
                (n instanceof FastpushContext && isFastpushed)
        ) as StackScope | undefined;
        if (node) {
            scopes.push(node as StackScope);
            node = node.parent || undefined;
        }
    }
    return scopes;
};

/**
 * Count from `start` to `end`, inclusive on each side.
 * Supports ascending and descending.
 */
const getIterator = (start: number, end: number) => {
    let i = start;
    return {
        hasNext: () => {
            if (start < end) {
                return i < end + 1;
            }
            return i >= end;
        },
        next: () => {
            if (start < end) {
                return i++;
            }
            return i--;
        },
        index: () => i,
    };
};

/** If terminal node, return token, otherwise return undefined */
export const getToken = (
    node: ParseTree | undefined | null
): Token | undefined =>
    node && node instanceof TerminalNode ? node.symbol : undefined;

export const getTokenType = (
    node: ParseTree | undefined
): number | undefined =>
    node && node instanceof TerminalNode ? node.symbol.type : undefined;

export const findRuleContext = (
    tokenStream: CommonTokenStream,
    syntaxTree: ParserRuleContext,
    position: Position
): ParserRuleContext | undefined => {
    const findTokenResult = LexerUtil.findToken(
        tokenStream.getTokens(),
        position
    );
    if (findTokenResult) {
        // Now, find the closest ancestor context of this token in the parse tree
        let result = syntaxTree;
        const findResult = (node: ParseTree): void => {
            // TODO this seems terribly inefficient - is it walking the whole tree?
            for (let i = 0; i < node.getChildCount(); i++) {
                let child = node.getChild(i);
                if (
                    child instanceof ParserRuleContext &&
                    child.start !== null &&
                    child.start.tokenIndex <= findTokenResult.index &&
                    child.stop &&
                    child.stop.tokenIndex >= findTokenResult.index
                ) {
                    result = child;
                    findResult(child); // Recursive call to go deeper if necessary
                    break;
                }
            }
        };
        // `result` now contains the closest context around the specified position
        findResult(syntaxTree);
        return result;
    }
};

export const printTreeString = (
    node: RuleContext | TerminalNode,
    indent: string = ''
): string => {
    let result = '';
    // Determine node type: RuleContext or TerminalNode
    if (node instanceof RuleContext) {
        const ruleName = node.constructor.name; // Get the rule name based on the class name
        result += `\n${indent}${ruleName}`;

        // Recursively print children
        for (let i = 0; i < node.getChildCount(); i++) {
            const child = node.getChild(i);
            result += printTreeString(child as RuleContext, indent + '  ');
        }
    } else if (node instanceof TerminalNode) {
        const symbol = node.symbol;
        const { text } = symbol;

        if (text?.trim() === '') return '';

        result += `\n${indent}'${text}'`;
    }
    return result;
};
