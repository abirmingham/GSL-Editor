import { Token } from 'antlr4ng';
import { Position } from 'vscode-languageserver';
import { GslLexer } from '../antlr/autogenerated/GslLexer';

/**
 * Variable number by uppercase variable name.
 */
const systemVariableMap = GslLexer.literalNames.reduce<Record<string, number>>(
    (memo, name, i) => {
        if (!name || name[1] !== '$') return memo;
        memo[name.slice(1, name.length - 1).toUpperCase()] = i;
        return memo;
    },
    {}
);

const systemVariables = new Set([
    GslLexer.SYS_REPLYADDRESS,
    GslLexer.SYS_PARSE_ERROR_1,
    GslLexer.SYS_PARSE_ERROR_2,
    GslLexer.SYS_PARSE_ERROR_3,
    GslLexer.SYS_PARSE_ERROR_4,
    GslLexer.SYS_BREAK,
    GslLexer.SYS_CALLBACK,
    GslLexer.SYS_CALLEDBY,
    GslLexer.SYS_DESCMODE,
    GslLexer.SYS_ERROR,
    GslLexer.SYS_LOADINGFROMSAVE,
    GslLexer.SYS_MAXLOOPS,
    GslLexer.SYS_MAXROOMCREATES,
    GslLexer.SYS_MAXTEXTCHANGES,
    GslLexer.SYS_MAXUOBJS,
    GslLexer.SYS_STRTABLE,
    GslLexer.SYS_INTTABLE,
    GslLexer.SYS_STIME,
    GslLexer.SYS_STRTABLE,
    GslLexer.SYS_INTTABLE,
    GslLexer.SYS_THISSCRIPT,
    GslLexer.SYS_TIME,
    GslLexer.SYS_USERS,
]);

export const Symbols = {
    Blocks: {
        Start: new Set([
            GslLexer.IF,
            GslLexer.IFNOT,
            GslLexer.LOOP,
            GslLexer.WHEN,
            GslLexer.IS,
            GslLexer.PUSH,
            GslLexer.FASTPUSH,
            GslLexer.DEFAULT,
            GslLexer.COLON,
        ]),
        Middle: new Set([GslLexer.ELSE, GslLexer.ELSE_IF, GslLexer.ELSE_IFNOT]),
        End: new Set([GslLexer.DOT, GslLexer.POP, GslLexer.FASTPOP]),
    },
    IfBlockTokens: new Set([
        GslLexer.IF,
        GslLexer.IFNOT,
        GslLexer.ELSE_IF,
        GslLexer.ELSE_IFNOT,
        GslLexer.ELSE,
    ]),
    Commands: new Set([
        GslLexer.ACTION,
        GslLexer.ADD_GROUP,
        GslLexer.ADDEFFECT,
        GslLexer.ADDEXPR,
        GslLexer.ADDMENUITEM,
        GslLexer.ALTWINOFF,
        GslLexer.ALTWINON,
        GslLexer.ANIM,
        GslLexer.ASSERT,
        GslLexer.ATTACK,
        GslLexer.BEHIND,
        GslLexer.BITGET,
        GslLexer.BITSET,
        GslLexer.BOLDOFF,
        GslLexer.BOLDON,
        GslLexer.BORDER,
        GslLexer.BUGREPORT,
        GslLexer.CALL,
        GslLexer.CALLMATCH,
        GslLexer.CALLPS,
        GslLexer.CANDO,
        GslLexer.CHECKEFFECT,
        GslLexer.CLEAR,
        GslLexer.CLEARMENU,
        GslLexer.CLEARTABLE,
        GslLexer.CLOSELOCKER,
        GslLexer.CMGR,
        GslLexer.COMPAREITEM,
        GslLexer.CONTRIBUTE,
        GslLexer.COPY,
        GslLexer.CREATE,
        GslLexer.CREATEITEM,
        GslLexer.CREATEROOM,
        GslLexer.CREATETABLE,
        GslLexer.CREATETEXT,
        GslLexer.CRITICAL,
        GslLexer.DECODEATTACK,
        GslLexer.DELETETABLE,
        GslLexer.DEPLOY,
        GslLexer.DIRADD,
        GslLexer.DIRSEND,
        GslLexer.DOCREATE,
        GslLexer.DOLOOK,
        GslLexer.DROP,
        GslLexer.ENCODEATTACK,
        GslLexer.END2EFFECT,
        GslLexer.ENDEFFECT,
        GslLexer.ENDNEFFECT,
        GslLexer.EXPAND,
        GslLexer.FEMISC,
        GslLexer.FEUPDATE,
        GslLexer.FILLTABLE,
        GslLexer.FIRSTBLOOD,
        GslLexer.FIRSTOBJ,
        GslLexer.FIRSTPLAYER,
        GslLexer.FIRSTWATCH,
        GslLexer.GATHER,
        GslLexer.GATHERFIRST,
        GslLexer.GATHERFIRSTROOM,
        GslLexer.GATHERNEXT,
        GslLexer.GATHERNEXTROOM,
        GslLexer.GATHERPLAYER,
        GslLexer.GETCONTRIBUTORS,
        GslLexer.GETINDEXOF,
        GslLexer.GETMAX,
        GslLexer.GETNAMEOF,
        GslLexer.GETPS,
        GslLexer.GETTABLE,
        GslLexer.GETTEXT,
        GslLexer.GETWATCH,
        GslLexer.GLUE,
        GslLexer.GROUND,
        GslLexer.HASH1,
        GslLexer.HASH2,
        GslLexer.HEAL,
        GslLexer.HEALP,
        GslLexer.HURT,
        GslLexer.HUSH,
        GslLexer.INFO,
        GslLexer.INFOITEM,
        GslLexer.INJURE,
        GslLexer.INPHRASE,
        GslLexer.INVENTORY,
        GslLexer.ISINJURED,
        GslLexer.ISNAMEFREE,
        GslLexer.ITEMSNAPSHOT,
        GslLexer.KILL,
        GslLexer.KILLALLNP,
        GslLexer.LAUNCH,
        GslLexer.LAUNCHURL,
        GslLexer.LOAD,
        GslLexer.LOADCHARDATA,
        GslLexer.LOG,
        GslLexer.LOGMSG,
        GslLexer.LOGTO,
        GslLexer.LOGTOINDEX,
        GslLexer.LOOKROOM,
        GslLexer.LOWERCASE,
        GslLexer.MMGR,
        GslLexer.MOVE,
        GslLexer.MSG,
        GslLexer.MSGFSYS,
        GslLexer.MSGGM,
        GslLexer.MSGP,
        GslLexer.MSGR,
        GslLexer.MSGRGM,
        GslLexer.MSGRX2,
        GslLexer.MSGRXP,
        GslLexer.MSGS,
        GslLexer.MSGSGM,
        GslLexer.MSGSYS,
        GslLexer.MSGW,
        GslLexer.NAMEEND,
        GslLexer.NAMESTART,
        GslLexer.NEXTBLOOD,
        GslLexer.NEXTEFFECT,
        GslLexer.NEXTNODE,
        GslLexer.NEXTOBJ,
        GslLexer.NEXTPLAYER,
        GslLexer.NEXTROOM,
        GslLexer.NEXTWATCH,
        GslLexer.OPENLOCKER,
        GslLexer.OR_YELL,
        GslLexer.OUTPHRASE,
        GslLexer.PARSE,
        GslLexer.PARSEDECIMAL,
        GslLexer.PAUSEEFFECTS,
        GslLexer.PID,
        GslLexer.PLAYERCOUNT,
        GslLexer.PREMPT,
        GslLexer.PROFILE,
        GslLexer.RANDOM,
        GslLexer.REM2EFFECT,
        GslLexer.REMEFFECT,
        GslLexer.REMMENUITEM,
        GslLexer.REMNEFFECT,
        GslLexer.REMOVE,
        GslLexer.REMOVEVARFIELD,
        GslLexer.REMOVEVARGROUP,
        GslLexer.RESIST,
        GslLexer.RESIZETABLE,
        GslLexer.RESTOREFIELDS,
        GslLexer.RESUMEEFFECTS,
        GslLexer.RMCALL,
        GslLexer.RNDDIR,
        GslLexer.RNDEXIT,
        GslLexer.RNDPLYR,
        GslLexer.ROLLIN,
        GslLexer.ROOMEND,
        GslLexer.ROOMSTART,
        GslLexer.ROOTEXISTOF,
        GslLexer.ROUNDTIME,
        GslLexer.SAVEFIELDS,
        GslLexer.SCAN,
        GslLexer.SCANEFFECT,
        GslLexer.SCRIPT,
        GslLexer.SET,
        GslLexer.SETNAME,
        GslLexer.SETTABLE,
        GslLexer.SETTEXT,
        GslLexer.SPARSE,
        GslLexer.START,
        GslLexer.STOP,
        GslLexer.STORECHARDATA,
        GslLexer.STOV,
        GslLexer.SUBMIT,
        GslLexer.SUBSTRING,
        GslLexer.TABLEINFO,
        GslLexer.TELLWEB,
        GslLexer.TEST_ASSERT,
        GslLexer.TEST2EFFECT,
        GslLexer.TESTEFFECT,
        GslLexer.TPARSE,
        GslLexer.UNDER,
        GslLexer.UNDEROFF,
        GslLexer.UNDERON,
        GslLexer.UNLOAD,
        GslLexer.UPDATESRVRSTUFF,
        GslLexer.UPDATETABLE,
        GslLexer.UPPERCASE,
        GslLexer.VERB,
        GslLexer.VTOS,
        GslLexer.WATCH,
        GslLexer.WHERE,
        GslLexer.WHEREAT,
        GslLexer.WHEREITEM,
        GslLexer.WRITECHAR,
    ]),
    Nodes: new Set([
        GslLexer.PLAYER_NODE,
        GslLexer.CREATURE_NODE,
        GslLexer.ROOM_NODE,
        GslLexer.OBJECT_NODE,
        GslLexer.EVENT_NODE,
    ]),
    Registers: new Set([
        GslLexer.V_REGISTER,
        GslLexer.A_REGISTER,
        GslLexer.B_REGISTER,
        GslLexer.S_REGISTER,
        GslLexer.T_REGISTER,
    ]),
    SystemVariables: systemVariables,
    Variables: new Set([
        GslLexer.S_REGISTER,
        GslLexer.T_REGISTER,
        GslLexer.PLAYER_NODE,
        GslLexer.V_REGISTER,
        GslLexer.A_REGISTER,
        GslLexer.B_REGISTER,
        GslLexer.PLAYER_NODE,
        GslLexer.ROOM_NODE,
        GslLexer.CREATURE_NODE,
        GslLexer.OBJECT_NODE,
        GslLexer.EVENT_NODE,
        ...systemVariables,
    ]),
    VariablesPushed: new Set([
        GslLexer.S_REGISTER,
        GslLexer.T_REGISTER,
        GslLexer.V_REGISTER,
        GslLexer.A_REGISTER,
        GslLexer.PLAYER_NODE,
        GslLexer.ROOM_NODE,
        GslLexer.CREATURE_NODE,
        GslLexer.OBJECT_NODE,
        GslLexer.EVENT_NODE,
    ]),
    VariablesFastpushed: new Set([
        GslLexer.S_REGISTER,
        GslLexer.V_REGISTER,
        GslLexer.A_REGISTER,
        GslLexer.PLAYER_NODE,
        GslLexer.ROOM_NODE,
        GslLexer.CREATURE_NODE,
        GslLexer.OBJECT_NODE,
        GslLexer.EVENT_NODE,
    ]),
    Paran: new Set([GslLexer.LPARAN, GslLexer.RPARAN]),
} as const;

interface VariableInfo {
    /** Lexer token number @example GslLexer.ROOM_NODE */
    type: number;
    /** Variable name @example 'NR2' */
    name: string;
}

export const getVariableFromTextToken = (
    txt: string
): VariableInfo | undefined => {
    txt = txt.toUpperCase();
    if (isNodeStringRef(txt)) {
        const name = `N${txt.slice(1)}`;
        if (txt[1] === 'P') {
            return { type: GslLexer.PLAYER_NODE, name };
        }
        if (txt[1] === 'C') {
            return { type: GslLexer.CREATURE_NODE, name };
        }
        if (txt[1] === 'R') {
            return { type: GslLexer.ROOM_NODE, name };
        }
        if (txt[1] === 'O') {
            return { type: GslLexer.OBJECT_NODE, name };
        }
        if (txt[1] === 'E') {
            return { type: GslLexer.EVENT_NODE, name };
        }
    }
    if (isRegisterStringRef(txt)) {
        const name = txt.slice(1);
        if (txt[1] === 'V') {
            return { type: GslLexer.V_REGISTER, name };
        }
        if (txt[1] === 'A') {
            return { type: GslLexer.A_REGISTER, name };
        }
        if (txt[1] === 'B') {
            return { type: GslLexer.B_REGISTER, name };
        }
        if (txt[1] === 'S') {
            return { type: GslLexer.S_REGISTER, name };
        }
        if (txt[1] === 'T') {
            return { type: GslLexer.T_REGISTER, name };
        }
    }
    if (systemVariableMap[txt] !== undefined) {
        return {
            type: systemVariableMap[txt],
            name: txt,
        };
    }
};

const isNodeStringRef = (txt: string): boolean =>
    txt.length === 3 &&
    txt[0] === '$' &&
    (txt[1] === 'P' ||
        txt[1] === 'C' ||
        txt[1] === 'R' ||
        txt[1] === 'O' ||
        txt[1] === 'E') &&
    String(Number(txt[2])) === txt[2];

const isRegisterStringRef = (txt: string): boolean =>
    txt.length === 3 &&
    txt[0] === '$' &&
    (txt[1] === 'V' ||
        txt[1] === 'A' ||
        txt[1] === 'B' ||
        txt[1] === 'S' ||
        txt[1] === 'T') &&
    String(Number(txt[2])) === txt[2];

export const isBlockSymbol = <T extends Token | number | undefined>(
    symbol: T
): symbol is Exclude<T, undefined> => {
    if (symbol === undefined) return false;
    const symbolNum = typeof symbol === 'number' ? symbol : symbol.type;
    return (
        Symbols.Blocks.Start.has(symbolNum) ||
        Symbols.Blocks.Middle.has(symbolNum) ||
        Symbols.Blocks.End.has(symbolNum)
    );
};

export interface FindTokenResult {
    token: Token;
    index: number;
}

export const findToken = (
    tokens: Token[],
    targetPosition: Position,
    options: { preferPredicate?: (a: Token, b: Token) => boolean } = {}
): FindTokenResult | undefined => {
    let startIdx = 0;
    let endIdx = tokens.length - 1;

    while (startIdx < endIdx) {
        // Binary search
        const middleIdx = startIdx + Math.floor((endIdx - startIdx) / 2);
        const relationship = comparePositionWithToken(
            tokens[middleIdx],
            targetPosition
        );
        if (relationship === -1) {
            endIdx = middleIdx - 1;
            continue;
        }
        if (relationship === 1) {
            startIdx = middleIdx + 1;
            continue;
        }
        // Target found; identify preferred result
        const result = tokens[middleIdx];
        const preferPredicate = options.preferPredicate;
        if (!preferPredicate) {
            return { token: result, index: middleIdx };
        }
        // If we're on a boundary, we have to decide which token we prefer
        const prevToken = tokens[middleIdx - 1];
        const isCursorAtStart = targetPosition.character === result.column;
        if (
            prevToken &&
            isCursorAtStart &&
            isLeftContiguous(prevToken, result) &&
            preferPredicate(prevToken, result)
        ) {
            // Left is contiguous and preferred
            return { token: prevToken, index: middleIdx - 1 };
        }
        const nextToken = tokens[middleIdx + 1];
        const isCursorAtEnd = targetPosition.character === getEndColumn(result);
        if (
            nextToken &&
            isCursorAtEnd &&
            isLeftContiguous(result, nextToken) &&
            preferPredicate(nextToken, result)
        ) {
            // Right is contiguous and preferred
            return { token: nextToken, index: middleIdx + 1 };
        }
        return { token: result, index: middleIdx };
    }
    if (comparePositionWithToken(tokens[startIdx], targetPosition) === 0) {
        return { token: tokens[startIdx], index: startIdx };
    }
    console.error('Failed to find token');
    return;
};

/**
 * @returns whether a is directly to the left of b; whitespace counts!
 */
const isLeftContiguous = (a: Token, b: Token): boolean =>
    a.column + (a.text?.length || 0) === b.column;

export const getEndColumn = ({
    column,
    text,
}: {
    column: number;
    text: string | undefined | null;
}): number => column + (text ? text.length : 0);

/**
 * @returns -1 if the position is less than the token,
 * 0 if the position is in the token
 * 1 if the position is greater than the token
 */
const comparePositionWithToken = (
    token: Token,
    targetPosition: Position
): -1 | 0 | 1 => {
    if (targetPosition.line + 1 < token.line) return -1;
    if (targetPosition.line + 1 > token.line) return 1;
    if (targetPosition.character < token.column) return -1;
    if (targetPosition.character > token.column + (token.text || '').length) {
        return 1;
    }
    return 0;
};

export const findTokens = (
    tokens: Token[],
    tokenType: number | number[],
    predicate?: (token: Token) => boolean | string | null | undefined
): Token[] => {
    const tokenTypes = new Set([
        ...(typeof tokenType === 'number' ? [tokenType] : tokenType),
    ]);
    return tokens.filter(
        (token) =>
            tokenTypes.has(token.type) && (!predicate || predicate(token))
    );
};

export const findPreviousToken = (
    tokens: Token[],
    startIdx: number,
    predicate: (t: Token) => boolean
): FindTokenResult | undefined => {
    for (let i = startIdx; i >= 0; i--) {
        if (predicate(tokens[i])) {
            return {
                token: tokens[i],
                index: i,
            };
        }
    }
    return;
};
